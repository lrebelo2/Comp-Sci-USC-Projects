<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Visualizations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="style.css" />
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/javascript" src="javascripts/d3/d3v3.js"></script>
    <script type="text/javascript" src="javascripts/d3/d3v3.geom.js"></script>
    <script type="text/javascript" src="javascripts/d3/d3v3.layout.js"></script>
    <script type="text/javascript" src="javascripts/CodeFlower.js"></script>
    <script type="text/javascript" src="javascripts/dataConverter.js"></script>
    <script type="text/javascript" src="javascripts/mainscript.js"></script>
    <script type="text/javascript" src="javascripts/d3.dependencyWheel.js"></script>
    <script src='https://unpkg.com/intersection-observer'></script>
    <script src='https://unpkg.com/scrollama'></script>
    <link href='http://fonts.googleapis.com/css?family=Rosario:400,700' rel='stylesheet' type='text/css'>
</head>

<body>
    <section>
        <h1>Visulizing systems from different perspectives</h1>
        <div class="other_section">
            <p>Current visulizations are over populated with information and looking for specific information is difficult. However, the main problem is that putting all information in one visualization is unreadable. To resolve this problem, we divided information in three visualizations to make them more readable and using d3 we provided interactive visualizations to help users access information easier.</p>
            <p>We developed three tools to create visualizations for a system's structure, dependencies and clusters. We show clustering for different architecture recovery methods.</p>
            <p>To be able to use the tools we introduced on this page, you need to provide outputs of different architecture recovery methods of a system along with source codes. The purpose and usage of each tool is available as you scroll and reach each one.</p>
           
        </div>

    </section>
    <h3>Now, sit back, pick a system, generate output files using ARC, RELAX, and ACDC, have source code ready and start scrolling</h3>
    <section id="scroll">
        <!-- graphic container -->
        <div class="scroll__graphic">
            <!-- actual graphic/chart -->
            <div class="chart">
                <button id="reset" title='Run Layout in Slow Motion'>Reset</button>
                <div id="visualization"></div>

            </div>
        </div>

        <!-- step/text container -->
        <div class="scroll__text">
            <div class="step" data-step="1">
                
                    <h1>Strutcure Visulization</h1>
                    <h4>Purpose</h4>
                    <p>This visualization helps us to dive into an existing project and have a bird's eye view of the whole code. It is useful for architects and developers to get a high-level idea about a system's structure without going through the code. This high-level view of a system shows the complexity of the system and it guides developers and architects to prioritize their actions.</p>
                     
                    <h4>Usage</h4>
                   <p> The input for this tool is a JSON file named &ltsystem name&gt_struct.js which is generated by a Java code. Please read README.md to understand how this file is generated. The Java file producing the JSON file is flexible and can target specific file types and it can show the structure of the system based on the path of the root directory. After submitting the input file, you see a graph with a black node located at the center of the graph. Nodes can be files or folders found in the target system. The Black node always shows the root node. The size of each file node is based on lines of code found in that file. Folders have the same small size all over the graph. Pointing on each node you can gain information about files and folders in the system. All nodes have names and lines of code information. Using dependencies files, a class file on the graph show the number of dependent classes and the number of classes depending on it. </p>
                   <p>Users always can click on a node to go through the structure from that node without other unnecessary files. A user can always go back to the initial state of the graph by clicking the reset button.</p>
                
                <div id="info"></div>
            </div>
            <div class="step" data-step="2">
                <h1>Dependencies Visulization</h1>
                    <h4>Purpose</h4>
                    Large systems can have very complex visualizations of its    dependencies and this visualization seeks to 
                    leverage the output of recoveries and package naming to illustrate dependencies between them rather
                    than just between code files themselves. Since developers separate concerns in their package and 
                    name them accordingly, this represents the dependencies on a multiple higher levels of abstraction.
                    For example, from: 
                            <p>depends<br>edu.berkeley.chukwa_xtrace.CausalGraph                          <br>org.apache.log4j.Logger</p>
        

                    We can extract 4 different relationships from "depends edu org" to "depends edu.berkeley org.apache" and so on... 
                    <h4>Usage</h4>
                Choose your ...deps.rsf file and click the Submit button. It will generate the graph showing the highest level of abstraction.<p>Moving the slider right changes the graph to show subsequentially lower abstraction levels</p>
            </div>
            <div class="step" data-step="3">
                <h1>Clusters Visulization</h1>
                    <h4>Purpose</h4>
                    Providing interactive visualization for clustering information gives developers and architects the opportunity of going through all information easier. This visualization helps users to compare the content of different clusters at a single glance. They are able to switch between different recovery methods using a drop down menu to look at the clusters from different viewpoints.
                    
                    <h4>Usage</h4>
                    Due to the lack of space and the nature of clustering information which creates a large graph. Clustering information are shown in another page to make it more readable. To redirect to clustering page, click on the gif.
                    When you are at cluster.html page, choose your target recovery method and the rsf file corresponding to the target system in Load directory. 
                    Please note that the input of this recovery method a JSON file generated before. To generate the input file, read the README.md file.
            </div>
        </div>

    </section>
    <section>
        <div class="other_section">
            <h1>Final Words</h1>
                    <p>Usage of these tools provides a more general view of the system leveraging the recovery outputs to provide:</p>
                    <p>- A bird's eye view of the whole code, showing the structure of the system that allows the architect or developer to gauge the system's complexity without looking at the code. </p>
                    <p>- An interactive way to gauge how separation of concerns is implemented in the system, as well as the complexity of its interdependencies.</p>
                    <p>- Comparision between the different recovery methods clustering algorithm, and how well they truly represent the system.</p>
        </div>
    </section>
    <script src="javascripts/scrollama.js"></script>


</body>



</html>
